<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Sorting - AlgoViz</title>

  <!-- Favicons -->
  <link href="assets/img/favicon.png" rel="icon" />
  <link href="assets/img/apple-touch-icon.png" rel="apple-touch-icon" />

  <!-- Material Icons and Fonts -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700" rel="stylesheet" />

  <!-- Main CSS File -->
  <link href="style.css" rel="stylesheet" />
</head>

<body>

  <!-- ======= Header ======= -->
  <header class="header">
    <h1 class="header-logo"><a href="index.html">AlgoViz</a></h1>
  </header>

  <main>
    <!-- ======= Breadcrumbs ======= -->
    <section id="breadcrumbs" class="breadcrumbs">
      <ol>
        <li><a href="index.html">Home</a></li>
        <li>Sorting</li>
      </ol>
      <h2>Sorting algorithms</h2>
    </section>

    <!-- ======= Overview Section ======= -->
    <section id="overview">
      <div class="section-title">
        <h2>Overview</h2>
        <p>
          A sorting algorithm is an algorithm that puts elements of a list in
          a certain order (thus sorting the list). The most frequently used
          orders are numerical order for lists of numbers and lexicographical
          order for lists of strings.
          <br /><br />
          To put it more formally, the output generally has to fulfill two
          conditions:
        </p>
        <ul>
          <li>The output is in nondecreasing order</li>
          <li>The output is a permutation of the input</li>
        </ul>
        <p>
          Or, to put it simply, when running a sorting algorithm we expect an
          output that contains all the elements originally present in the
          input arranged in such a way that the smallest element (according to
          the operation used to sort the list) is in the leftmost place, with
          every element following being either bigger or equal to its
          predecessor.
          <br /><br />
          Sorting algorithms can generally be classified into three distinct
          categories:
        </p>
        <ul>
          <li>Comparison sorts</li>
          <li>Non-comparison sorts</li>
          <li>Others</li>
        </ul>
        <p>
          On this page, you can find many implementations for every category.
          If you need a visualization for a certain algorithm, just use the
          search function to find it quickly.
        </p>
      </div>
    </section>

    <!-- ======= Search Section ======= -->
    <section class="search">
      <div class="section-title">
        <h2>Search</h2>
      </div>

      <div class="search-container">
        <input id="search" class="search-input" type="search" placeholder="Search names or keywords" />
      </div>
    </section>

    <!-- ======= Search Results Section ======= -->
    <section id="search-results">
      <div id="results" class="card-grid"></div>
    </section>

    <div class="types">
      <!-- ======= Comparison Sorts Section ======= -->
      <section id="comparison-sorts">
        <div class="section-title">
          <h2>Comparison Sorts</h2>
          <p>
            A comparison sort is a type of sorting algorithm that only reads the
            list elements through a single abstract comparison operation that
            determines which of two elements should occur first in the final
            sorted list.
          </p>
        </div>

        <div class="card-grid">
          <div id="bubblesort" class="card-item">
            <a href="bubblesort.html">
              <h4>Bubble Sort</h4>
              <p>
                Bubblesort is a simple sorting algorithm that repeatedly steps
                through the list, compares adjacent elements, and swaps them if
                they are in the wrong order.
                <br /><br />
                <b>Best-case:</b> <i>O(n)</i><br />
                <b>Average-case:</b> <i>O(n²)</i> <br />
                <b>Worst-case:</b> <i>O(n²)</i><br />
              </p>
            </a>
          </div>

          <div id="cocktailshakersort" class="card-item">
            <a href="cocktailshakersort.html">
              <h4>Cocktail Shaker Sort</h4>
              <p>
                Cocktail Shaker Sort is a variation of bubble sort that sorts in
                both directions on each pass through the list.
                <br /><br />
                <b>Best-case:</b> <i>O(n)</i><br />
                <b>Average-case:</b> <i>O(n²)</i> <br />
                <b>Worst-case:</b> <i>O(n²)</i><br />
              </p>
            </a>
          </div>

          <div id="combsort" class="card-item">
            <a href="combsort.html">
              <h4>Comb Sort</h4>
              <p>
                Combsort is an extension of bubble sort. It compares elements
                divided by a gap which shrinks after each pass through the list.
                <br /><br />
                <b>Best-case:</b> <i>O(n log n)</i><br />
                <b>Average-case:</b> <i>O(n²)</i> <br />
                <b>Worst-case:</b> <i>O(n²)</i><br />
              </p>
            </a>
          </div>

          <div id="gnomesort" class="card-item">
            <a href="gnomesort.html">
              <h4>Gnome Sort</h4>
              <p>
                The gnome sort is a sorting algorithm that is similar to
                insertion sort but sorts by a series of swaps, similar to bubble
                sort.
                <br /><br />
                <b>Best-case:</b> <i>O(n)</i><br />
                <b>Average-case:</b> <i>O(n²)</i> <br />
                <b>Worst-case:</b> <i>O(n²)</i><br />
              </p>
            </a>
          </div>

          <div id="insertionsort" class="card-item">
            <a href="insertionsort.html">
              <h4>Insertion Sort</h4>
              <p>
                Insertion sort is a simple sorting algorithm that builds the
                final sorted list one item at a time by inserting each element
                at its correct position.
                <br /><br />
                <b>Best-case:</b> <i>O(n)</i><br />
                <b>Average-case:</b> <i>O(n²)</i> <br />
                <b>Worst-case:</b> <i>O(n²)</i><br />
              </p>
            </a>
          </div>

          <div id="mergesort" class="card-item">
            <a href="mergesort.html">
              <h4>Merge Sort</h4>
              <p>
                Mergesort is a divide-and-conquer algorithm that works by
                dividing the unsorted list into two approximately equal
                sublists, sorting them, and then merging them back together.
                <br /><br />
                <b>Best-case:</b> <i>O(n log n)</i><br />
                <b>Average-case:</b> <i>O(n log n)</i> <br />
                <b>Worst-case:</b> <i>O(n log n)</i><br />
              </p>
            </a>
          </div>

          <div id="quicksort" class="card-item">
            <a href="quicksort.html">
              <h4>Quick Sort</h4>
              <p>
                Quicksort is a divide-and-conquer algorithm. It selects a pivot
                element, partitions the array into two sub-arrays, and then
                sorts them recursively.
                <br /><br />
                <b>Best-case:</b> <i>O(n log n)</i><br />
                <b>Average-case:</b> <i>O(n log n)</i> <br />
                <b>Worst-case:</b> <i>O(n²)</i><br />
              </p>
            </a>
          </div>

          <div id="selectionsort" class="card-item">
            <a href="selectionsort.html">
              <h4>Selection Sort</h4>
              <p>
                Selection sort repeatedly selects the smallest remaining element
                and swaps it with the first unsorted element, building a sorted
                list one element at a time.
                <br /><br />
                <b>Best-case:</b> <i>O(n²)</i><br />
                <b>Average-case:</b> <i>O(n²)</i> <br />
                <b>Worst-case:</b> <i>O(n²)</i><br />
              </p>
            </a>
          </div>
        </div>
      </section>

      <div class="divider"></div>

      <!-- ======= Non-Comparison Sorts Section ======= -->
      <section id="non-comparison-sorts">
        <div class="section-title">
          <h2>Non-Comparison Sorts</h2>
          <p>
            Non-Comparison Sorts are sorting algorithms that sort a given input
            without comparing the elements, instead making certain assumptions
            about the data. Examples include Counting Sort, which sorts using
            key-value, and Bucket Sort, which examines bits of keys.
          </p>
        </div>

        <div class="card-grid">
          <div id="countingsort" class="card-item">
            <a href="countingsort.html">
              <h4>Counting Sort</h4>
              <p>
                Counting sort is an algorithm for sorting a collection of
                objects according to keys that are small integers. It operates
                by counting the number of objects that have each distinct key
                value, and using arithmetic on those counts to determine the
                positions of each key value in the output sequence.
                <br /><br />
                <b>Time complexity:</b> <i>O(n+k)</i><br />
                with n being the number of elements and k being the number of
                keys.
              </p>
            </a>
          </div>

          <div id="radixsort" class="card-item">
            <a href="radixsort.html">
              <h4>Radix Sort</h4>
              <p>
                Radix sort avoids comparison by creating and distributing
                elements into buckets according to their radix. For elements
                with more than one significant digit, this bucketing process is
                repeated for each digit while preserving the ordering of the
                prior step, until all digits have been considered.
                <br /><br />
                <b>Time complexity:</b> <i>O(nw)</i><br />
                with n being the number of elements and w being the key length.
              </p>
            </a>
          </div>
        </div>
      </section>

      <div class="divider"></div>

      <!-- ======= Others Section ======= -->
      <section id="other-sorts">
        <div class="section-title">
          <h2>Others</h2>
          <p>
            Algorithms in this category are impractical for real-life use in
            traditional software contexts due to extremely poor performance or
            specialized hardware requirements. These sorts are usually described
            for educational purposes to demonstrate how the runtime of
            algorithms is estimated.
          </p>
        </div>

        <div class="card-grid">
          <div id="bogosort" class="card-item">
            <a href="bogosort.html">
              <h4>Bogo Sort</h4>
              <p>
                Bogosort is a highly inefficient sorting algorithm based on the
                generate and test paradigm. The function successively generates
                permutations of its input until it finds one that is sorted. An
                analogy for the working of the algorithm is to sort a deck of
                cards by throwing the deck into the air, picking the cards up at
                random, and repeating the process until the deck is sorted.
                <br /><br />
                <b>Best-case:</b> <i>O(n)</i><br />
                <b>Average-case:</b> <i>O((n+1)!)</i> <br />
                <b>Worst-case:</b> <i>unbounded</i><br />
              </p>
            </a>
          </div>
        </div>
      </section>
    </div>
  </main>

  <a href="#" class="back-to-top">
    <i class="material-icons">arrow_upward</i>
  </a>

  <!-- Main JS File -->
  <script src="assets/js/main.js"></script>
  <script>
    function filterAlgorithms(searchTerm = "") {
      const resultsContainer = document.querySelector("#results");
      const categoriesContainer = document.querySelector(".types");
      const algorithmCards = categoriesContainer.querySelectorAll(".card-item");

      // Hide all algorithms initially
      categoriesContainer.style.display = "none";
      resultsContainer.innerHTML = "";

      if (searchTerm === "") {
        // Show all categories and algorithms if the search term is empty
        categoriesContainer.style.display = "block";
        resultsContainer.innerHTML = "";
      } else {
        // Clear previous results and filter based on the search term
        let hasResults = false;

        algorithmCards.forEach(card => {
          const cardTitle = card.querySelector("h4").textContent.toLowerCase();
          if (cardTitle.includes(searchTerm)) {
            resultsContainer.appendChild(card.cloneNode(true));
            hasResults = true;
          }
        });

        if (!hasResults) {
          resultsContainer.innerHTML = `No results matching "${searchTerm}".`;
        }
      }
    }

    document.querySelector("#search").addEventListener("input", function () {
      filterAlgorithms(this.value.toLowerCase().trim());
    });
  </script>

</body>

</html>